// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: payments.sql

package database

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const checkBalance = `-- name: CheckBalance :one
SELECT balance FROM wallets WHERE owner_role = $1 AND owner_id = $2
`

type CheckBalanceParams struct {
	OwnerRole string
	OwnerID   uuid.UUID
}

func (q *Queries) CheckBalance(ctx context.Context, arg CheckBalanceParams) (string, error) {
	row := q.db.QueryRowContext(ctx, checkBalance, arg.OwnerRole, arg.OwnerID)
	var balance string
	err := row.Scan(&balance)
	return balance, err
}

const createAuditLog = `-- name: CreateAuditLog :one
INSERT INTO audit_logs(id, user_role, user_id, action, created_at, updated_at)
VALUES($1, $2, $3, $4, $5, $6)
RETURNING id, user_role, user_id, action, updated_at, created_at
`

type CreateAuditLogParams struct {
	ID        uuid.UUID
	UserRole  sql.NullString
	UserID    uuid.UUID
	Action    string
	CreatedAt time.Time
	UpdatedAt time.Time
}

func (q *Queries) CreateAuditLog(ctx context.Context, arg CreateAuditLogParams) (AuditLog, error) {
	row := q.db.QueryRowContext(ctx, createAuditLog,
		arg.ID,
		arg.UserRole,
		arg.UserID,
		arg.Action,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var i AuditLog
	err := row.Scan(
		&i.ID,
		&i.UserRole,
		&i.UserID,
		&i.Action,
		&i.UpdatedAt,
		&i.CreatedAt,
	)
	return i, err
}

const createEscrowAccount = `-- name: CreateEscrowAccount :one
INSERT INTO escrow_accounts(id, investor_id, business_id, amount, status, created_at, updated_at, released_at)
VALUES($1, $2, $3, $4, $5, $6, $7, $8)
RETURNING id, investor_id, business_id, amount, status, created_at, updated_at, released_at
`

type CreateEscrowAccountParams struct {
	ID         uuid.UUID
	InvestorID uuid.UUID
	BusinessID uuid.UUID
	Amount     string
	Status     string
	CreatedAt  time.Time
	UpdatedAt  time.Time
	ReleasedAt sql.NullTime
}

func (q *Queries) CreateEscrowAccount(ctx context.Context, arg CreateEscrowAccountParams) (EscrowAccount, error) {
	row := q.db.QueryRowContext(ctx, createEscrowAccount,
		arg.ID,
		arg.InvestorID,
		arg.BusinessID,
		arg.Amount,
		arg.Status,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.ReleasedAt,
	)
	var i EscrowAccount
	err := row.Scan(
		&i.ID,
		&i.InvestorID,
		&i.BusinessID,
		&i.Amount,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ReleasedAt,
	)
	return i, err
}

const createTransaction = `-- name: CreateTransaction :one
INSERT INTO transactions(id, wallet_id, amount, transaction_type, related_escrow_id, idempotency_key, created_at, updated_at)
VALUES($1, $2, $3, $4, $5, $6, $7, $8)
ON CONFLICT (idempotency_key) DO NOTHING
RETURNING id, wallet_id, amount, transaction_type, related_escrow_id, idempotency_key, updated_at, created_at
`

type CreateTransactionParams struct {
	ID              uuid.UUID
	WalletID        uuid.UUID
	Amount          string
	TransactionType string
	RelatedEscrowID uuid.NullUUID
	IdempotencyKey  sql.NullString
	CreatedAt       time.Time
	UpdatedAt       time.Time
}

func (q *Queries) CreateTransaction(ctx context.Context, arg CreateTransactionParams) (Transaction, error) {
	row := q.db.QueryRowContext(ctx, createTransaction,
		arg.ID,
		arg.WalletID,
		arg.Amount,
		arg.TransactionType,
		arg.RelatedEscrowID,
		arg.IdempotencyKey,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var i Transaction
	err := row.Scan(
		&i.ID,
		&i.WalletID,
		&i.Amount,
		&i.TransactionType,
		&i.RelatedEscrowID,
		&i.IdempotencyKey,
		&i.UpdatedAt,
		&i.CreatedAt,
	)
	return i, err
}

const createWallet = `-- name: CreateWallet :one
INSERT INTO wallets(id, owner_role, owner_id, balance, currency, created_at, updated_at)
VALUES($1, $2, $3, $4, $5, $6, $7)
RETURNING id, owner_role, owner_id, balance, currency, created_at, updated_at
`

type CreateWalletParams struct {
	ID        uuid.UUID
	OwnerRole string
	OwnerID   uuid.UUID
	Balance   string
	Currency  string
	CreatedAt time.Time
	UpdatedAt time.Time
}

func (q *Queries) CreateWallet(ctx context.Context, arg CreateWalletParams) (Wallet, error) {
	row := q.db.QueryRowContext(ctx, createWallet,
		arg.ID,
		arg.OwnerRole,
		arg.OwnerID,
		arg.Balance,
		arg.Currency,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var i Wallet
	err := row.Scan(
		&i.ID,
		&i.OwnerRole,
		&i.OwnerID,
		&i.Balance,
		&i.Currency,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deductFunds = `-- name: DeductFunds :one
UPDATE wallets 
SET balance = balance - $3, updated_at = Now()
WHERE owner_role = $1 AND owner_id = $2 AND balance >= $3
RETURNING id, owner_role, owner_id, balance, currency, created_at, updated_at
`

type DeductFundsParams struct {
	OwnerRole string
	OwnerID   uuid.UUID
	Balance   string
}

func (q *Queries) DeductFunds(ctx context.Context, arg DeductFundsParams) (Wallet, error) {
	row := q.db.QueryRowContext(ctx, deductFunds, arg.OwnerRole, arg.OwnerID, arg.Balance)
	var i Wallet
	err := row.Scan(
		&i.ID,
		&i.OwnerRole,
		&i.OwnerID,
		&i.Balance,
		&i.Currency,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const depositFunds = `-- name: DepositFunds :one
UPDATE wallets 
SET balance = balance + $3, updated_at = Now()
WHERE owner_role = $1 AND owner_id = $2
RETURNING id, owner_role, owner_id, balance, currency, created_at, updated_at
`

type DepositFundsParams struct {
	OwnerRole string
	OwnerID   uuid.UUID
	Balance   string
}

func (q *Queries) DepositFunds(ctx context.Context, arg DepositFundsParams) (Wallet, error) {
	row := q.db.QueryRowContext(ctx, depositFunds, arg.OwnerRole, arg.OwnerID, arg.Balance)
	var i Wallet
	err := row.Scan(
		&i.ID,
		&i.OwnerRole,
		&i.OwnerID,
		&i.Balance,
		&i.Currency,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const escrowRefund = `-- name: EscrowRefund :one
UPDATE escrow_accounts
SET status = 'refunded', updated_at = Now()
WHERE id = $1 AND status = 'pending'
RETURNING id, investor_id, business_id, amount, status, created_at, updated_at, released_at
`

func (q *Queries) EscrowRefund(ctx context.Context, id uuid.UUID) (EscrowAccount, error) {
	row := q.db.QueryRowContext(ctx, escrowRefund, id)
	var i EscrowAccount
	err := row.Scan(
		&i.ID,
		&i.InvestorID,
		&i.BusinessID,
		&i.Amount,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ReleasedAt,
	)
	return i, err
}

const getEscrowByCompanyID = `-- name: GetEscrowByCompanyID :many
SELECT id, investor_id, business_id, amount, status, created_at, updated_at, released_at FROM escrow_accounts WHERE business_id = $1
`

func (q *Queries) GetEscrowByCompanyID(ctx context.Context, businessID uuid.UUID) ([]EscrowAccount, error) {
	rows, err := q.db.QueryContext(ctx, getEscrowByCompanyID, businessID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []EscrowAccount
	for rows.Next() {
		var i EscrowAccount
		if err := rows.Scan(
			&i.ID,
			&i.InvestorID,
			&i.BusinessID,
			&i.Amount,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ReleasedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEscrowByCustomerID = `-- name: GetEscrowByCustomerID :many
SELECT id, investor_id, business_id, amount, status, created_at, updated_at, released_at FROM escrow_accounts WHERE investor_id = $1
`

func (q *Queries) GetEscrowByCustomerID(ctx context.Context, investorID uuid.UUID) ([]EscrowAccount, error) {
	rows, err := q.db.QueryContext(ctx, getEscrowByCustomerID, investorID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []EscrowAccount
	for rows.Next() {
		var i EscrowAccount
		if err := rows.Scan(
			&i.ID,
			&i.InvestorID,
			&i.BusinessID,
			&i.Amount,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ReleasedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEscrowByID = `-- name: GetEscrowByID :one
SELECT id, investor_id, business_id, amount, status, created_at, updated_at, released_at FROM escrow_accounts WHERE id = $1
`

func (q *Queries) GetEscrowByID(ctx context.Context, id uuid.UUID) (EscrowAccount, error) {
	row := q.db.QueryRowContext(ctx, getEscrowByID, id)
	var i EscrowAccount
	err := row.Scan(
		&i.ID,
		&i.InvestorID,
		&i.BusinessID,
		&i.Amount,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ReleasedAt,
	)
	return i, err
}

const getWallet = `-- name: GetWallet :one
SELECT id, owner_role, owner_id, balance, currency, created_at, updated_at FROM wallets WHERE owner_role = $1 AND owner_id = $2
`

type GetWalletParams struct {
	OwnerRole string
	OwnerID   uuid.UUID
}

func (q *Queries) GetWallet(ctx context.Context, arg GetWalletParams) (Wallet, error) {
	row := q.db.QueryRowContext(ctx, getWallet, arg.OwnerRole, arg.OwnerID)
	var i Wallet
	err := row.Scan(
		&i.ID,
		&i.OwnerRole,
		&i.OwnerID,
		&i.Balance,
		&i.Currency,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const releaseEscrowAccount = `-- name: ReleaseEscrowAccount :one
UPDATE escrow_accounts
SET status = 'released', released_at = Now(), updated_at = Now()
WHERE id = $1 AND status = 'pending'
RETURNING id, investor_id, business_id, amount, status, created_at, updated_at, released_at
`

func (q *Queries) ReleaseEscrowAccount(ctx context.Context, id uuid.UUID) (EscrowAccount, error) {
	row := q.db.QueryRowContext(ctx, releaseEscrowAccount, id)
	var i EscrowAccount
	err := row.Scan(
		&i.ID,
		&i.InvestorID,
		&i.BusinessID,
		&i.Amount,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ReleasedAt,
	)
	return i, err
}
